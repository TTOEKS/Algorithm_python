"""
Python3 표준 자료형

None -> None
숫자 -> 실수 (float), 정수(int), 불리언(bool)
집합 -> 집합 (set)
  * 중복된 값을 가지지 않는 자료형
  * 입력 순서 유지 X, 중복된 값 허용 X
매핑 -> 딕셔너리 (dict)
  * 키와 자료형으로 구성된 복합 자료형
시퀀스
  * 특정 대상의 순서 있는 나열
  * 가변: 리스트 (list)
    * 값 변경 가능
  * 불변: 문자열 (str), 튜플 (tuple), 바이트 (bytes)
    * 값 변경 불가능

파이썬은 임의 정밀도 정수형을 지원
  * 무제한 자릿수를 제공하는 정수형
  * C -> int (고정 정밀도), long (임의 정밀도) / Python -> int (임의 정밀도)
  * 게산속도는 저하되지만, 단일형으로 처리가능하며 오버플로 고민 없음

C, JAVA는 원시타입 제공
  * 메모리에 정확하게 타입 크기만큼의 공간을 할당 후 값을 채움 (매우 빠름)
  * 물리 메모리에 자료형의 크기만큼 공간을 갖는 요소가 연속 배치
  * 파이썬의 경우 원시타입은 제공하지 않고 모든 자료형을 객체로 제공

추상 자료형 (ADT: Abstract Data Type)
  * 해당 자료형의 연산들을 명시한 것
  * 행동만 정의하고, 실제 구현 방법에 대해서는 명시 X
  * 추상화 (필수적인 속성만 보여주고, 불필요한 정보는 감춤)와 비슷
  * 인터페이스만 보여주고, 실제 구현을 보여주지 않음
"""


if __name__=="__main__":
    # 정수형
    print("True == 1: ", True == 1)
    print("False == 0: ", False == 0)

    ### 집합과 딕셔너리 모두 {}로 표현 -> 파이썬 컴파일러가 타입 결정을 자동으로 수행
    # 집합
    set_a = {'a', 'b', 'c'}

    # 딕셔너리
    dict_a = {'a':'A', 'b':'B', 'c':'C'}

    # 시퀀스
    # 변수는 단순히 메모리를 참조할 뿐, 값을 변경하면 다른 주소의 메모리르 참조
    # 기존 데이터는 메모리에 남아 있음
    str_a = 'abc'
    print(id('abc') == id(str_a))

    str_a = 'def'
    print(id("def") == id(str_a))
 
    # 비교 (is와 ==)
      # is: id() 값을 비교하는 함수 (주소)
      # ==: 값을 비교하는 연산





